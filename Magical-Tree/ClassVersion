var a;
var g;
var p;
function setup() {
  createCanvas(900, 700);
  a = new treeBackground();
  g = new ground();
  p = new createTree();
  a.draw();
  g.draw()
  p.draw()
}

function draw() {
  
}

class treeBackground {

  constructor() {
    this.bg = createGraphics(width, height);
  }

  draw() {
    this.bg.noStroke();
    for (this.diam = 1.5 * width; this.diam > 0.5 * width; this.diam -= 20) {
        this.bg.fill(map(this.diam, 0.5 * width, 1.5 * width, 255, 110)); // changed this to make the gradient more pronounced
        this.bg.ellipse(width / 2, height / 2, this.diam, this.diam);
    }
    image(this.bg, 0, 0);
  }

}

class ground {

  constructor() {
    this.n = 0;
  }
  
  draw() {
    fill(20);
    beginShape();
    vertex(0, height);
    for (this.i = 0; this.i <= width; this.i += 50) {
        vertex(this.i, map(noise(this.n), 0, 1, height - 30, height));
        this.n += 0.1;
    }
    vertex(width, height);
    endShape();
  }

}

class createTree {

  constructor() {
    this.tree = createGraphics(width, height);
    this.n = 0;
  }

  draw() {
    this.tree.beginShape();
    this.tree.noStroke();
    this.tree.background(0,0);
		
    for (let i = 0; i < 3; i++) {
        this.tree.fill(map(i, 0, 2, 60, 20));
        this.branch(width/2, height, 70, -HALF_PI, 150, 0);
    }
    this.tree.endShape();
    image(this.tree, 5, 5);
  }


  branch(x, y, bSize, theta, bLength, pos) {
    
    this.n += 0.01;
    let diam = lerp(bSize, 0.7 * bSize, pos / bLength);
    diam *= map(noise(this.n), 0, 1, 0.4, 1.6);

    this.tree.ellipse(x, y, diam, diam);
    if (bSize > 0.6) {
        if (pos < bLength) {
            x += cos(theta + random(-PI / 10, PI / 10));
            y += sin(theta + random(-PI / 10, PI / 10));
            this.branch( x, y, bSize, theta, bLength, pos + 1);
        } else {
            let drawLeftBranch = random(1) > 0.1;
            let drawRightBranch = random(1) > 0.1;
            if (drawLeftBranch) this.branch(x, y, random(0.5, 0.7) * bSize, theta - random(PI / 15, PI / 5), random(0.6, 0.8) * bLength, 0);
            if (drawRightBranch) this.branch(x, y, random(0.5, 0.7) * bSize, theta + random(PI / 15, PI / 5), random(0.6, 0.8) * bLength, 0);

            if (!drawLeftBranch && !drawRightBranch) {
                this.tree.push()
                this.tree.translate(x, y);
                this.tree.rotate(theta);
                this.tree.quad(0, -diam / 2, 2 * diam, -diam / 6, 2 * diam, diam / 6, 0, diam / 2);
                this.tree.pop();
            }
        }
    }
  }
}

  

